<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello world!</title>
</head>
<body>
    <div style="width: 50%">
        <div style="width: 50%">Hello world!</div>
      </div>
      <script>
        var name='dwdaw';
        var gender = '男';
        var age = 19;
        // 对象属于一种复合的数据类型，可以保存多个不同的数据类型的属性
        // 对象的分类
        /*
        1.内建对象
            由ES标准中定义的对象
        2。宿主对象
            由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象
            DOM，BOM
        3.自定义对象
        */
        var obj = new Object()
        // 使用new关键字调用的函数，是构造函数，是专门用来构建对象的函数
        // 向对象中添加 属性 ,在对象中保存的值叫属性
        // 对象.属性名=属性值；
        obj.name = "孙悟空";
        obj.gender = "男";
        obj.age = 18;

        // 读取对象属性
        // 对象.属性名
        console.log(obj.name);

        // 修改对象属性
        // 对象.属性名 = 值
        obj.name = "tom";
        console.log(obj.name);

        // 删除对象属性
        // delete 对象.属性名
        delete obj.name;
// 属性值属性值


        var obj = new Object();
        obj.name = "Tom";// 属性名什么都可以，特殊的属性名用：对象["属性名"] = 属性值（读取时也是这个方式）
        // 属性值什么类型都可以，也可以是一个对象
        var obj2= new Object();
        obj2.name = "1111";
        obj.name = obj2;
        console.log(obj.name);
        // 直接将obj2对象打印出来
        // 可以这样输出obj.name.name
        /*
        in运算符 可以检查一个对象中是否含有指定的属性
        返回false/true
        */
        //检查    
        console.log("test" in obj);
        // 输出false

//基本和引用数据类型

        // 基本数据类型string number booling null undefined
        // 引用数据类型object
        var obj = new Object();
        obj.name="tom";
        obj2= obj;
        // 这时候改变obj，obj2也会变：这就是与基本数据类型的区别
        // js变量都是保存在栈中，基本数据类型的值值直接在栈内存里保存
        // 引用数据类型是保存到堆内存中（p49）

// 使用对象字面量创建对象
        var obj = {};
        obj.name = "tom";
        // 可以在创建对象时直接指定对象中的属性(属性名可加引号)若使用特殊的名字得加引号
        // 属性名和属性是一组一组名值对结构
        var obj2 = {
            name :"baby",
            age:28,
            gender:"nan"
        };

// 创建函数
        // 可以将要封装的代码以字符串的形式传递给构造函数
        var fun = new Function("console.log('hello');");
        // 调用时执行
        fun();
        // 函数也是对象
        fun.name= "tom";

        // 使用函数声明来创建一个函数
        // function 函数名（）{}
        function fun2(){
            console.log("daw");
        }

        //fun3保存function这个匿名函数 
        var fun3 = function(){
            console.log("~~");
        };// 赋值语句最好写分号，上面的不用写

        // 立即执行函数,函数定义完立即被调用，往往只会执行一次
        (function(){
            alert();
        })();
        (function(a,b){

        })(123,456);


// 

        // 函数也可以作为对象的属性--变成方法,调用这个函数就是调用对象的方法
        obj.sayname=function(){
            console.log("");
        };

// 枚举对象中的属性
        // 每次执行时会将对象中的一个属性赋值给变量
        for(var a in obj){
            console.log(obj.n);//但用.的形式不能使用变量
            console.log(obj[n]);//正确
            console.log(obj["n"]);//错误，和.n一样了
        }


// 作用域（scope）
        // 1.在全局变量中，创建的变量都会作为window对象的属性保存
        var a= 1;
        console.log(window.a);// 正确
        // 2.创建的函数都会作为window对象的方法保存
        // 函数声明
        // 使用var关键字声明的变量，会在所有代码执行之前被声明（但是不会被赋值）
        // 使用函数声明形式创建函数function 函数（）{}会在所有代码执行之前被创建，不仅声明而且被创建，所以可以在函数声明前被调用
        // 用var fun= function（）{}不会被提前创建
        
// 函数作用域
        
// this
        // 1.以函数的形式调用时，this永远都是window
        // 2.以方法的形式调用时，this就是调用方法的那个对象
        var name = "tom";
        function fun(){
            console.log(this.name);
        }
        var obj={
            name:"marry",
            sayname:fun
        };
        var obj2={
            name:"tim",
            sayname:fun
        }
        obj.sayname();
        obj2.sayname();
        // 会根据调用的对象不同this会改变

// 使用工厂方法创建一个对象
        // 创建对象过程中有大量重复性代码
        function creatpearon(name,age,gender){
            // 创建一个新对象
            var obj= new Object();
            // 向对象中添加属性
            obj.name= name,
            obj.age=age,
            obj.gender=gender
            // 返回对象
            return obj;
        }
        var obj2= creatperson("tom",28,"男");

// 构造函数
        // 使用工厂方法创建的对象，使用的构造函数都是object，(168行创建对象时都是new object)
        // 所以创建的对象都是object这个类型
        // 就导致我们无法区分出多种不同类型的对象
        // p64

        // 希望
        var obj= new Person();//但是报错

        // 创建一个构造函数，专门用来创建对象
            // 构造函数就是一个普通的函数，创建方式和普通函数没有区别
            // 不同的是构造函数习惯上首字母大写
        // 构造函数和普通函数的区别就是调用方式不同
            // 普通函数是直接调用，而-需使用new关键字调用
        // 构造函数执行流程
            // 1.立刻创建一个新的对象
            // 2.将新建的对象设置为这个函数中的this
            // 3.执行函数中的代码
            // 4.将新建的对象作为返回值返回
        function Person(){
            // alert(this);
            this.naem="123";//向对象里添加属性
            this.age=18;
            this.sayname=function(){
                alert(this);
            };
        }

        var per = new Person();
        // 使用同一个构造函数创建的对象属于同一类

        // 使用instanceof可以检查一个对象是否属于一个类的实例
            // 对象 instanceof 构造函数
        console.log(per instanceof Person);
            // 返回true 或 false
            // 所有对象都是Object的后代
        // this的情况
            // 1.当以函数的形式调用时this是window
            // 2.当以方法的形式调用时，谁调用方法this就是谁
            // 3.当以构造函数的形式调用时，this就是新创建的那个对象

// 构造函数的修改
        // 创建一个Person的构造函数
            // 在Person构造函数中，为每一个对象都添加了一个sayname方法
                // 目前我们的方法都是在构造函数内部创建的
                // 也就是每执行一次都会创建一个新的方法
                // 也就是所有实例sayname都是唯一的
                // 这样就导致了构造函数执行一次就会创建一个新的方法
                    // 这样没有必要，完全可以使所有对象共享一个方法

                // 将sayname方法在全局作用域中定义

                function Person(){
                    this.sayname=fun;
                }
                function fun(){
                    alert();
                }
                // 问题：将函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中也很不安全，重名益被覆盖
// 原型对象
        // 原型prototype
            //我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
                // 这个属性指向着一个原型对象
            // 如果函数作为普通函数调用prototype没有任何作用
            // 当函数作为构造函数形式被调用，他所创建的对象都会有一个隐含属性
                // 指向该构造函数的原型对象，我们可以通过__proto__访问该属性
            // 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象和里面的**属性**、**方法**
                // 我们可以将对象中共有的内容，统一到原型对象中
            // 当我们访问对象的一个属性或方法时，它会在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，找到则会直接使用

        function Person(){

        }
        Person.prototype.sayname=function(){
            alert(this.name);
        };
        // 不影响全局作用域，以后我们创建函数时，可以将这些对象共有的属性和方法，统一添加到函数的原型对象里

// 原型对象，原型链
        function Myclass(){

        }
        var mc = new Myclass();
        // 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
        // 可以使用对象的hasOwnProperty检查对象自身中是否有该属性，使用该方法只有对象自身中含有属性时，才会返回true
        console.log(mc.hasOwnProperty("hasOwnProperty"));
        // 返回false
        console.log(mc.__proto__.hasOwnProperty("hasOwnProperty"));
        // 也返回false，说明它不在mc的原型对象中

        // 原型对象也是对象，所以它也有原型
        console.log(mc.__proto__.__proto__.hasOwnProperty("hasOwnProperty"));
        // true

        // 原型的原型的原型就不存在了，也就是知道找到Object对象原型

        // 当我们使用一个对象的属性和方法时
            // 自身如果有，就直接使用
            // 如果没有则去原型对象中寻找，如果原型对象中有，则使用
            // 如果没有则取原型的原型中寻找，知道找到Object对象的原型
            // Object对像的原型没有原型，如果在Object中依然没有找到，则返回undefined

// toString()
        // 将任意数据类型转换成字符串的方法
        function Person(name){
            this.name = name;
        }
        var per = new Person("tom");
        console.log(per);
        // 当我们直接在页面中打印一个对象时，实际上是输出对象的tostring的返回值
        console.log(per);//==console.log(per.toString());
        // tostring存在于
        console.log(mc.__proto__.__proto__.hasOwnProperty("toString"));
        // 如果我们希望在输出对象时不输出[Object Object],可以在对象里添加一个toString()方法
        Pereson.prototype.toString = function(){
            return "Person[name="+this.name+"]";// 加号别忘记
        }

// 垃圾回收


// 内建对象：数组
        // 创建数组对象,添加元素
        var arr = new Array();
        arr[0]=0;
        console.log(arr.length);
        arr[arr.length]=9;// 会向数组最后一个位置添加元素

        var arr=["hello",1,true,obj];
        // 可以是任何数据类型
      </script>
</body>
</html>